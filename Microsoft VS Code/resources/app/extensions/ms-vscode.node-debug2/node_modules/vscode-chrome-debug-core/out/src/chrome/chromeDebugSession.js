"use strict";
/*---------------------------------------------------------
 * Copyright (C) Microsoft Corporation. All rights reserved.
 *--------------------------------------------------------*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const os = require("os");
const vscode_debugadapter_1 = require("vscode-debugadapter");
const telemetry_1 = require("../telemetry");
function isMessage(e) {
    return !!e.format;
}
function isChromeError(e) {
    return !!e.data;
}
class ChromeDebugSession extends vscode_debugadapter_1.LoggingDebugSession {
    /**
     * This needs a bit of explanation -
     * The Session is reinstantiated for each session, but consumers need to configure their instance of
     * ChromeDebugSession. Consumers should call getSession with their config options, then call
     * DebugSession.run with the result. Alternatively they could subclass ChromeDebugSession and pass
     * their options to the super constructor, but I think this is easier to follow.
     */
    static getSession(opts) {
        // class expression!
        return class extends ChromeDebugSession {
            constructor(debuggerLinesAndColumnsStartAt1, isServer) {
                super(debuggerLinesAndColumnsStartAt1, isServer, opts);
            }
        };
    }
    constructor(obsolete_debuggerLinesAndColumnsStartAt1, obsolete_isServer, opts) {
        super(opts.logFilePath, obsolete_debuggerLinesAndColumnsStartAt1, obsolete_isServer);
        logVersionInfo();
        this._extensionName = opts.extensionName;
        this._debugAdapter = new opts.adapter(opts, this);
        const safeGetErrDetails = err => {
            let errMsg;
            try {
                errMsg = err.stack ? err.stack : JSON.stringify(err);
            }
            catch (e) {
                errMsg = 'Error while handling previous error: ' + e.stack;
            }
            return errMsg;
        };
        process.on('uncaughtException', (err) => {
            vscode_debugadapter_1.logger.error(`******** Unhandled error in debug adapter: ${safeGetErrDetails(err)}`);
            throw err;
        });
        process.addListener('unhandledRejection', (err) => {
            // Node tests are watching for the ********, so fix the tests if it's changed
            vscode_debugadapter_1.logger.error(`******** Unhandled error in debug adapter - Unhandled promise rejection: ${safeGetErrDetails(err)}`);
        });
    }
    /**
     * Overload dispatchRequest to the debug adapters' Promise-based methods instead of DebugSession's callback-based methods
     */
    dispatchRequest(request) {
        // We want the request to be non-blocking, so we won't await for reportTelemetry
        this.reportTelemetry(`clientRequest/${request.command}`, { requestType: request.type }, (reportFailure) => __awaiter(this, void 0, void 0, function* () {
            const response = new vscode_debugadapter_1.Response(request);
            try {
                vscode_debugadapter_1.logger.verbose(`From client: ${request.command}(${JSON.stringify(request.arguments)})`);
                if (!(request.command in this._debugAdapter)) {
                    reportFailure("The debug adapter doesn't recognize this command");
                    this.sendUnknownCommandResponse(response, request.command);
                }
                else {
                    response.body = yield this._debugAdapter[request.command](request.arguments, request.seq);
                    this.sendResponse(response);
                }
            }
            catch (e) {
                if (!this.isEvaluateRequest(request.command, e)) {
                    reportFailure(e);
                }
                this.failedRequest(request.command, response, e);
            }
        }));
    }
    // { command: request.command, type: request.type };
    reportTelemetry(eventName, propertiesSpecificToAction, action) {
        return __awaiter(this, void 0, void 0, function* () {
            const startProcessingTime = process.hrtime();
            const properties = propertiesSpecificToAction;
            let failed = false;
            const sendTelemetry = () => {
                const NanoSecondsPerMillisecond = 1000000;
                const MillisecondsPerSecond = 1000;
                const ellapsedTime = process.hrtime(startProcessingTime);
                const ellapsedMilliseconds = ellapsedTime[0] * MillisecondsPerSecond + ellapsedTime[1] / NanoSecondsPerMillisecond;
                properties.timeTakenInMilliseconds = ellapsedMilliseconds.toString();
                telemetry_1.telemetry.reportEvent(eventName, properties);
            };
            const reportFailure = e => {
                failed = true;
                properties.successful = "false";
                properties.exceptionMessage = e.toString();
                if (e instanceof Error) {
                    properties.exceptionName = e.name;
                    properties.exceptionStack = e.stack;
                }
                sendTelemetry();
            };
            // We use the reportFailure callback because the client might exit immediately after the first failed request, so we need to send the telemetry before that, if not it might get dropped
            yield action(reportFailure);
            if (!failed) {
                properties.successful = "true";
                sendTelemetry();
            }
        });
    }
    isEvaluateRequest(requestType, error) {
        return !isMessage(error) && (requestType === 'evaluate');
    }
    failedRequest(requestType, response, error) {
        if (isMessage(error)) {
            this.sendErrorResponse(response, error);
            return;
        }
        if (this.isEvaluateRequest(requestType, error)) {
            // Errors from evaluate show up in the console or watches pane. Doesn't seem right
            // as it's not really a failed request. So it doesn't need the [extensionName] tag and worth special casing.
            response.message = error ? error.message : 'Unknown error';
            response.success = false;
            this.sendResponse(response);
            return;
        }
        const errMsg = isChromeError(error) ?
            error.message + ': ' + error.data :
            (error.stack || error.message);
        vscode_debugadapter_1.logger.error(`Error processing "${requestType}": ${errMsg}`);
        // These errors show up in the message bar at the top (or nowhere), sometimes not obvious that they
        // come from the adapter, so add extensionName
        this.sendErrorResponse(response, 1104, '[{_extensionName}] Error processing "{_requestType}": {_stack}', { _extensionName: this._extensionName, _requestType: requestType, _stack: errMsg }, vscode_debugadapter_1.ErrorDestination.Telemetry);
    }
    sendUnknownCommandResponse(response, command) {
        this.sendErrorResponse(response, 1014, `[${this._extensionName}] Unrecognized request: ${command}`, null, vscode_debugadapter_1.ErrorDestination.Telemetry);
    }
}
exports.ChromeDebugSession = ChromeDebugSession;
function logVersionInfo() {
    vscode_debugadapter_1.logger.log(`OS: ${os.platform()} ${os.arch()}`);
    vscode_debugadapter_1.logger.log(`Adapter node: ${process.version} ${process.arch}`);
    vscode_debugadapter_1.logger.log('vscode-chrome-debug-core: ' + require('../../../package.json').version);
}

//# sourceMappingURL=chromeDebugSession.js.map
